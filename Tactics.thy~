theory Tactics
 imports Main "HOL-Analysis.Analysis" "HOL.Numeral_Simprocs" "HOL-Number_Theory.Number_Theory"
begin

lemma disj_swap:
  shows "P \<or> Q \<Longrightarrow> Q \<or> P"
  apply(erule disjE)
   apply(rule disjI2)
   apply(assumption)
  apply(rule disjI1)
  apply(assumption)
  done

lemma disj_swap_with_tactics:
  shows "P \<or> Q \<Longrightarrow> Q \<or> P"
  apply(tactic \<open>eresolve_tac @{context} [@{thm disjE}] 1\<close>)
   apply(tactic \<open>resolve_tac @{context} [@{thm disjI2}] 1\<close>)
   apply(tactic \<open>assume_tac @{context} 1\<close>)
  apply(tactic \<open>resolve_tac @{context} [@{thm disjI1}] 1\<close>)
  apply(tactic \<open>assume_tac @{context} 1\<close>)
  done

ML \<open>
let
  val ctxt = @{context}
  val goal = @{prop "P \<or> Q \<Longrightarrow> Q \<or> P"}
in
  Goal.prove ctxt ["P", "Q"] [] goal
    (fn _ => eresolve_tac @{context} [@{thm disjE}] 1
              THEN resolve_tac @{context} [@{thm disjI2}] 1
              THEN assume_tac @{context} 1
              THEN resolve_tac @{context} [@{thm disjI1}] 1
              THEN assume_tac @{context} 1) 
end
\<close>

lemma sin_pi_2: "sin(x + pi/2) = cos(x)" 
  by (simp add: sin_cos_eq)

lemma cos_periods:
  fixes k' :: int and k :: real
  assumes "k  \<equiv> 2 * of_int k'" 
  shows "cos (x + k*pi) \<equiv> cos (x)" 
  (is "?cos1 \<equiv> ?cos2")
proof -
  have "cos (x + k*pi) \<equiv> 
        cos (x + k'*(2*pi))"
    using assms by(simp add: algebra_simps)
  also have "... \<equiv> cos (x)" (is "?a \<equiv> ?b")
  proof -
    have "cos (x + k'*(2*pi)) = cos (x)" 
      using sin_cos_eq_iff by fastforce
    then show "?a \<equiv> ?b"
      by auto
  qed
  finally show "cos (x + k*pi) \<equiv> cos (x)"
    by auto
qed

lemma "sin(x+8*pi+pi/2) = cos x" 
  apply(tactic \<open>EqSubst.eqsubst_tac @{context} [1] [@{thm sin_pi_2}] 1\<close>)
  apply(tactic \<open>EqSubst.eqsubst_tac @{context} [1] 
                [@{thm cos_periods[of 8 "8 div 2",simplified]}] 1\<close>)
  by(tactic \<open>simp_tac @{context} 1\<close>)+

lemma "sin(x+8*pi+pi/2) = cos x" 
  by(tactic \<open>EqSubst.eqsubst_tac @{context} [1] [@{thm sin_pi_2}] 1
             THEN EqSubst.eqsubst_tac @{context} [1] 
                [@{thm cos_periods[of 8 "8 div 2",simplified]}] 1
             THEN simp_tac @{context} 1
             THEN simp_tac @{context} 1\<close>)
  
ML \<open>
let
  val ctxt = @{context}
  val goal = @{prop "sin(x+8*pi+pi/2) = cos x"}
in
  Goal.prove ctxt ["x"] [] goal
    (fn _ => EqSubst.eqsubst_tac @{context} [1] [@{thm sin_pi_2}] 1
             THEN EqSubst.eqsubst_tac @{context} [1] 
                [@{thm cos_periods[of 8 "8 div 2",simplified]}] 1
             THEN simp_tac @{context} 1
             THEN simp_tac @{context} 1) 
end
\<close>

ML \<open>
val ct = @{cterm "sqrt 2"} ;
(* 
  dest_comb transforms the first application tree into pairs
  here, extract the sqrt, then extract the num conversion then convert to number
*)
ct |> Thm.term_of |> dest_comb |> snd |> dest_comb |> snd |> HOLogic.dest_numeral
\<close>

ML \<open>
val ct = @{cterm "sin(x+4*pi+pi/2)"} ;
val sum = ct |> Thm.term_of |> dest_comb |> snd 
\<close>

ML \<open>
val x = sum |> dest_comb |> fst |> dest_comb |> snd 
            |> dest_comb |> fst |> dest_comb |> snd
val k = sum |> dest_comb |> fst |> dest_comb |> snd 
            |> dest_comb |> snd |> dest_comb |> fst
            |> dest_comb |> snd |> dest_comb |> snd |> HOLogic.dest_numeral
\<close>


(* Instead of seeing if there is pi/2 just produce two theorems: one for pi/2 and one
   without pi/2. The real variability is in the coefficient of pi. *)
ML \<open>
fun rewrite_sine ctxt ct =
  let
    val sum = ct |> Thm.term_of |> dest_comb |> snd 
    val x = sum |> dest_comb |> fst |> dest_comb |> snd 
            |> dest_comb |> fst |> dest_comb |> snd
    val k = sum |> dest_comb |> fst |> dest_comb |> snd 
            |> dest_comb |> snd |> dest_comb |> fst
            |> dest_comb |> snd |> dest_comb |> snd |> HOLogic.dest_numeral
    val goal = @{term "sin(x+8*pi+pi/2) = cos x"}
  in
    Goal.prove ctxt ["x"] [] goal
      (fn _ => EqSubst.eqsubst_tac ctxt [1] [@{thm sin_pi_2}] 1
               THEN EqSubst.eqsubst_tac ctxt [1] 
                  [@{thm cos_periods[of 8 "8 div 2",simplified]}] 1
               THEN simp_tac ctxt 1
               THEN simp_tac ctxt 1) 
  end
\<close>



end